% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MDBinom.r
\name{AR_boot}
\alias{AR_boot}
\title{Wylicza rozkład AR(GINI) metodą bootstrap}
\usage{
AR_boot(
  score,
  def,
  n_boot,
  obs = rep(1, length(score)),
  n_once = 5e+07,
  seed = NULL
)
}
\arguments{
\item{score}{wektor z wartościami score.}

\item{def}{wektor z liczbą defaultów dla danego rekordu danych.}

\item{n_boot}{liczba prób bootstrap do wygenerowania.}

\item{obs}{wektor z liczbą obserwacji dla danego rekordu danych.}

\item{n_once}{ile jednorazowo maksymalnie może być wylosowanych obserwacji. Parametr dodany jedynie, 
aby nie przekroczyć dostępnej pamięci. Nie ma wpływu na końcowy wynik.}

\item{seed}{ziarno.}
}
\value{
Zwraca wektor długości \code{b_boot+1}. Pierwszy element wektora
			 zawiera wyliczony AR na całej próbie, w dalszej kolejności znajdują
			 się wartości wyliczone w oparciu o próby bootstrap.
}
\description{
Algorytm działa w następujący sposób. Na wstępie agregowane są wartości
do poziomu score. Tak przygotowane informacje posłużą
do wygenerowania losowo liczby badów i goodów dla każdego score, jakie zostałyby wylosowane
w eksperymencie losowania ze zwracaniem z wyjściowej próby. 
Jednorazowo losowanych jest tyle prób bootstrap, aby liczba wszystkich wylosowanych 
obserwacji
nie przekroczyła \code{n_once}. Ma to zapobiec przekroczeniu dostępnej wielkości pamięci.
Z wylosowanych obserwacji tworzone są macierze
do funkcji \code{\link{AR_quick}}, gdzie jedna kolumna odpowiada jedemu eksperymentowi. 
Jeśli liczba kolumn w macierzy jest mniejsza niż \code{n_boot}, co może być
spowodowane ograniczeniem przez \code{n_once}, wykonywana jest
kolejna pętla. Algorytm został zoptymalizowany pod kątem prób, w których
występuje mała liczba unikalnych wartości \code{score}, w stosunku do liczby obserwacji w próbie.
}
\details{
Dane wejściowe mogą być już w jakiś sposób zagregowane (np.do poziomu score), lub nie.
}
\examples{
## dane do przykĹ‚adu
n<-100000; #liczba obserwacji w prĂłbie
nb<-100; #liczba prĂłb bootstrap
score<-rnorm(n); #generowanie score
def<-as.numeric(score+rnorm(n)<0) #generowanie defaultĂłw
score<-floor(200*score) #dyskretyzacja wartoĹ›ci score

#liczba unikalnych wartoĹ›ci score
length(unique(score))
#[1] 1362

#czas wykonania
system.time(AR_boot(score, def, nb))
#user  system elapsed 
# .41    0.00    1.53 

#porĂłwnanie z czasem wykonania w przypadku pÄ™tli i stadradowej funkcji 
#do wyliczania GINI
system.time(
sapply(1:nb, function(i){
			id<-sample(length(score), replace=TRUE);
			AR(score[id], def[id])['AR']
	})
) 
# user  system elapsed 
#83.66    1.62   92.44 
}
\author{
Michał Danaj
}
