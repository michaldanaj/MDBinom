% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MDBinom.r
\name{AR_boot}
\alias{AR_boot}
\title{Wylicza rozk³ad AR(GINI) metod¹ bootstrap}
\usage{
AR_boot(score, def, n_boot, obs = rep(1, length(score)), n_once = 5e+07,
  seed = NULL)
}
\arguments{
\item{score}{wektor z wartoœciami score.}

\item{def}{wektor z liczb¹ defaultów dla danego rekordu danych.}

\item{n_boot}{liczba prób bootstrap do wygenerowania.}

\item{obs}{wektor z liczb¹ obserwacji dla danego rekordu danych.}

\item{n_once}{ile jednorazowo maksymalnie mo¿e byæ wylosowanych obserwacji. Parametr dodany jedynie, 
aby nie przekroczyæ dostêpnej pamiêci. Nie ma wp³ywu na koñcowy wynik.}

\item{seed}{ziarno.}
}
\value{
Zwraca wektor d³ugoœci \code{b_boot+1}. Pierwszy element wektora
			 zawiera wyliczony AR na ca³ej próbie, w dalszej kolejnoœci znajduj¹
			 siê wartoœci wyliczone w oparciu o próby bootstrap.
}
\description{
Algorytm dzia³a w nastêpuj¹cy sposób. Na wstêpie agregowane s¹ wartoœci
do poziomu score. Tak przygotowane informacje pos³u¿¹
do wygenerowania losowo liczby badów i goodów dla ka¿dego score, jakie zosta³yby wylosowane
w eksperymencie losowania ze zwracaniem z wyjœciowej próby. 
Jednorazowo losowanych jest tyle prób bootstrap, aby liczba wszystkich wylosowanych 
obserwacji
nie przekroczy³a \code{n_once}. Ma to zapobiec przekroczeniu dostêpnej wielkoœci pamiêci.
Z wylosowanych obserwacji tworzone s¹ macierze
do funkcji \code{\link{AR_quick}}, gdzie jedna kolumna odpowiada jedemu eksperymentowi. 
Jeœli liczba kolumn w macierzy jest mniejsza ni¿ \code{n_boot}, co mo¿e byæ
spowodowane ograniczeniem przez \code{n_once}, wykonywana jest
kolejna pêtla. Algorytm zosta³ zoptymalizowany pod k¹tem prób, w których
wystêpuje ma³a liczba unikalnych wartoœci \code{score}, w stosunku do liczby obserwacji w próbie.
}
\details{
Dane wejœciowe mog¹ byæ ju¿ w jakiœ sposób zagregowane (np.do poziomu score), lub nie.
}
\examples{
## dane do przyk³adu
n<-100000; #liczba obserwacji w próbie
nb<-100; #liczba prób bootstrap
score<-rnorm(n); #generowanie score
def<-as.numeric(score+rnorm(n)<0) #generowanie defaultów
score<-floor(200*score) #dyskretyzacja wartoœci score

#liczba unikalnych wartoœci score
length(unique(score))
#[1] 1362

#czas wykonania
system.time(AR_boot(score, def, nb))
#user  system elapsed 
# .41    0.00    1.53 

#porównanie z czasem wykonania w przypadku pêtli i stadradowej funkcji 
#do wyliczania GINI
system.time(
sapply(1:nb, function(i){
			id<-sample(length(score), replace=TRUE);
			AR(score[id], def[id])[[1]]['AR']
	})
) 
# user  system elapsed 
#83.66    1.62   92.44 
}
\author{
Micha³ Danaj
}

